<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Burraco Counter – Auto (Template Matching)</title>
<!-- OpenCV.js and Tesseract.js from CDN (Tesseract kept as optional fallback, but not required now) -->
<script async src="https://docs.opencv.org/4.8.0/opencv.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<style>
  :root{ --bg:#0b1a13; --card:#0f241a; --muted:#97b3a5; --accent:#2dd4bf; --line:#183528; }
  html,body{margin:0;height:100%}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial; background:linear-gradient(180deg,#05210f,#0b1a13); color:#e7f4ee}
  .wrap{max-width:1100px;margin:0 auto;padding:16px 16px 120px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
  h1{font-size:22px;margin:0;font-weight:800;letter-spacing:.2px}
  .btn{border:1px solid var(--line);background:#0f3023;color:#eafff7;border-radius:12px;padding:10px 14px;cursor:pointer;font-weight:600}
  .btn:active{transform:translateY(1px)}
  .btn.secondary{background:#10261d}
  .btn.ghost{background:transparent}
  .pill{border-radius:999px;border:1px solid var(--line);padding:6px 10px;margin-right:6px;background:#0c2018}
  .stat{display:flex;align-items:center;gap:8px;border:1px dashed var(--line);border-radius:12px;padding:10px 12px;background:#0c2218}
  .stat .k{color:var(--muted);font-weight:600}
  .stat .v{font-weight:900;font-size:18px}
  .footer{position:fixed;left:0;right:0;bottom:0;background:rgba(5,18,13,.85);backdrop-filter:saturate(120%) blur(6px);border-top:1px solid var(--line)}
  .footer .inner{max-width:1100px;margin:0 auto;padding:12px 16px}
  .result{display:flex;align-items:center;justify-content:space-between}
  .total{font-size:28px;font-weight:900}
  .imgbox{position:relative;border-radius:16px;overflow:hidden;border:1px solid var(--line);background:#0e2119;display:grid;grid-template-columns:1fr 380px;gap:12px;min-height:220px}
  .panel{padding:12px}
  .hint{color:var(--muted);font-size:12px}
  canvas{max-width:100%;height:auto;background:#0d2018}
  .row{display:flex;justify-content:space-between;align-items:center;border:1px solid var(--line);background:#0e2018;border-radius:10px;padding:6px 10px;margin-bottom:6px}
  .small{font-size:12px;color:var(--muted)}
  .tag{display:inline-block;border:1px solid var(--line);padding:3px 8px;border-radius:999px;background:#0c2018;margin:2px}
  .progress{height:6px;background:#0a1c14;border-radius:6px;overflow:hidden;border:1px solid var(--line)}
  .progress>div{height:100%;background:var(--accent);width:0%}
  label.switch{display:inline-flex;align-items:center;gap:8px;margin-right:12px}
  .note{color:#fde68a;font-size:12px}
  @media (max-width:1000px){.imgbox{grid-template-columns:1fr}}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Burraco Counter – Riconoscimento automatico (Template Matching)</h1>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <label class="btn" for="pick">Scatta/Carica foto</label>
        <input id="pick" type="file" accept="image/*" capture="environment" hidden>
        <button id="analyzeBtn" class="btn">Riconosci punteggi</button>
        <button id="preciseBtn" class="btn secondary">Modalità precisa</button>
        <button id="rulesBtn" class="btn secondary">Regole</button>
        <button id="resetBtn" class="btn ghost">Pulisci</button>
      </div>
    </header>

    <div class="imgbox">
      <div class="panel">
        <div class="hint" style="margin-bottom:8px">Scatta dall’alto, buona luce. Carte a tavola verticali; carte da pagare orizzontali. Pozzetto non preso a faccia in giù vicino alle carte da pagare.</div>
        <canvas id="canvas"></canvas>
      </div>
      <div class="panel" style="border-left:1px solid var(--line)">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px">
          <strong>Stato</strong>
          <div class="progress" style="flex:1"><div id="progress"></div></div>
        </div>
        <div id="status" class="small" style="margin:6px 0 10px">Pronto</div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px">
          <div class="stat"><span class="k">Carte a tavola</span><span class="v" id="stat-pos">0</span></div>
          <div class="stat"><span class="k">Carte da pagare</span><span class="v" id="stat-neg">0</span></div>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px">
          <div class="stat"><span class="k">Bonus totali</span><span class="v" id="stat-bonus">0</span></div>
          <div class="stat"><span class="k">TOTALE</span><span class="v" id="stat-total">0</span></div>
        </div>
        <div style="margin:8px 0"><strong>Dettaglio carte</strong> <span class="small">(tocca una riga per correggere rango/orientamento)</span></div>
        <div id="detail" class="small" style="max-height:260px;overflow:auto;border:1px solid var(--line);border-radius:10px;padding:6px"></div>
        <div style="margin-top:10px">
          <span class="tag">Burraco Puri: <span id="bp">0</span></span>
          <span class="tag">Semipuri: <span id="bs">0</span></span>
          <span class="tag">Impuri: <span id="bi">0</span></span>
        </div>
        <div style="margin-top:6px">
          <label class="switch"><input type="checkbox" id="chiusura"> Chiusura</label>
          <label class="switch"><input type="checkbox" id="pozzetto"> Pozzetto NON preso</label>
        </div>
        <div class="note" style="margin-top:6px">Se qualcosa non viene letto, tocca la riga e correggi: il totale si aggiorna subito.</div>
      </div>
    </div>
  </div>

  <div class="footer">
    <div class="inner" style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <div class="stat"><span class="k">Carte a tavola</span> <span class="v" id="f-pos">0</span></div>
        <div class="stat"><span class="k">Carte da pagare</span> <span class="v" id="f-neg">0</span></div>
        <div class="stat"><span class="k">Bonus totali</span> <span class="v" id="f-bonus">0</span></div>
      </div>
      <div class="result"><span class="k" style="margin-right:10px">TOTALE</span> <span class="total" id="f-total">0</span></div>
    </div>
  </div>

  <!-- Dialog Regole -->
  <dialog id="rulesDlg" style="border:none;border-radius:16px;padding:0;max-width:520px;width:92%">
    <form method="dialog" style="background:#0b1a13;color:#e7f4ee;border:1px solid var(--line);border-radius:16px;overflow:hidden">
      <div style="padding:14px 16px;border-bottom:1px solid var(--line);display:flex;justify-content:space-between;align-items:center"><strong>Regole & Bonus</strong><button class="btn secondary" value="close">Chiudi</button></div>
      <div style="padding:14px;display:grid;gap:10px">
        <div class="small">Valori carte (classico ITA): 3–7=5, 8–K=10, A=15, 2=20, Jolly=30.</div>
        <label>Bonus Burraco Puro <input type="number" id="r-puro" /></label>
        <label>Bonus Burraco Semipuro <input type="number" id="r-semi" /></label>
        <label>Bonus Burraco Impuro <input type="number" id="r-imp" /></label>
        <label>Bonus Chiusura <input type="number" id="r-chius" /></label>
        <label>Penalità Pozzetto non preso <input type="number" id="r-pozz" /></label>
      </div>
      <div style="padding:14px;border-top:1px solid var(--line);display:flex;justify-content:flex-end;gap:8px"><button class="btn secondary" value="cancel">Annulla</button><button class="btn" id="saveRules" value="default">Salva</button></div>
    </form>
  </dialog>

<script>
/* Utils */
const sleep = ms=>new Promise(r=>setTimeout(r,ms));
const setText = (id,v)=>document.getElementById(id).textContent=String(v);
const setStatus = t=>document.getElementById('status').textContent=t;
const setProg = p=>document.getElementById('progress').style.width = Math.max(0,Math.min(100,p))+'%';
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

/* Domain */
const RANKS = ["Jolly","2","3","4","5","6","7","8","9","10","J","Q","K","A"]; // logical order
const SHOW_ORDER = ["Jolly","2","A","K","Q","J","10","9","8","7","6","5","4","3"];
const CARD_VALUES = {"3":5,"4":5,"5":5,"6":5,"7":5,"8":10,"9":10,"10":10,"J":10,"Q":10,"K":10,"A":15,"2":20,"Jolly":30};
const rulesDefaults = { puro:200, semi:150, imp:100, chius:100, pozz:-100 };
let rules = JSON.parse(localStorage.getItem('rules-burraco')||'null') || rulesDefaults;

/* State */
const state = {
  laid: Object.fromEntries(SHOW_ORDER.map(r=>[r,0])),
  pay:  Object.fromEntries(SHOW_ORDER.map(r=>[r,0])),
  bp:0, bs:0, bi:0,
  chius:false, pozz:false,
  detail: [], // {rank, orientation, score}
  precise:false,
};

/* Scoring */
function sum(bag){ return Object.entries(bag).reduce((a,[rank,c])=> a + (CARD_VALUES[rank]||0)*c, 0); }
function bonus(){ let b = state.bp*rules.puro + state.bs*rules.semi + state.bi*rules.imp; if(state.chius) b+=rules.chius; if(state.pozz) b+=rules.pozz; return b; }
function recalc(){
  const pos = sum(state.laid); const neg = sum(state.pay); const bon = bonus(); const tot = pos - neg + bon;
  setText('stat-pos', pos); setText('stat-neg', neg); setText('stat-bonus', bon); setText('stat-total', tot);
  setText('f-pos', pos); setText('f-neg', neg); setText('f-bonus', bon); setText('f-total', tot);
}

/* UI rules dialog */
const dlg = document.getElementById('rulesDlg');
document.getElementById('rulesBtn').addEventListener('click', ()=>{
  r_puro.value=rules.puro; r_semi.value=rules.semi; r_imp.value=rules.imp; r_chius.value=rules.chius; r_pozz.value=rules.pozz;
  dlg.showModal();
});
document.getElementById('saveRules').addEventListener('click', ()=>{
  rules={ puro:+r_puro.value||0, semi:+r_semi.value||0, imp:+r_imp.value||0, chius:+r_chius.value||0, pozz:+r_pozz.value||0 };
  localStorage.setItem('rules-burraco', JSON.stringify(rules));
  recalc();
});
document.getElementById('chiusura').addEventListener('change', e=>{ state.chius=e.target.checked; recalc(); });
document.getElementById('pozzetto').addEventListener('change', e=>{ state.pozz=e.target.checked; recalc(); });

['bp','bs','bi'].forEach(id=>{
  document.getElementById(id).addEventListener('click', ()=>{ state[id]=(state[id]+1)%10; setText(id,state[id]); recalc(); });
});

/* Canvas */
const input = document.getElementById('pick');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
let imgBitmap = null;
input.addEventListener('change', async ()=>{
  const f = input.files && input.files[0]; if(!f) return;
  const bitmap = await createImageBitmap(f, {imageOrientation:'from-image'});
  const maxW = 1400; const scale = Math.min(1, maxW/bitmap.width);
  canvas.width = Math.round(bitmap.width*scale);
  canvas.height= Math.round(bitmap.height*scale);
  ctx.drawImage(bitmap,0,0,canvas.width,canvas.height);
  imgBitmap = bitmap;
  setStatus('Immagine caricata. Pronto al riconoscimento.'); setProg(0);
});

document.getElementById('resetBtn').addEventListener('click', ()=>{
  ctx.clearRect(0,0,canvas.width,canvas.height);
  state.detail = []; Object.keys(state.laid).forEach(k=>state.laid[k]=0); Object.keys(state.pay).forEach(k=>state.pay[k]=0);
  // manteniamo i bonus
  updateDetail(); recalc(); setStatus('Pronto'); setProg(0);
});
document.getElementById('preciseBtn').addEventListener('click', ()=>{
  state.precise = !state.precise;
  document.getElementById('preciseBtn').textContent = state.precise ? 'Modalità precisa ✓' : 'Modalità precisa';
});

/* Detail list with manual correction */
function updateDetail(){
  const d = document.getElementById('detail'); d.innerHTML='';
  if(!state.detail.length){ d.innerHTML='<div class="small">Nessuna carta riconosciuta (ancora)</div>'; return; }
  state.detail.forEach((c,idx)=>{
    const row = document.createElement('div'); row.className='row'; row.style.cursor='pointer';
    row.innerHTML = `<span>#${idx+1} – ${c.rank||'?'} <span class="small">(${c.orientation==='vertical'?'tavola':'pagare'})</span> <span class="small">[score ${c.score?.toFixed(2)??'-'}]</span></span>
                     <span>${CARD_VALUES[c.rank]||0} pt</span>`;
    row.addEventListener('click', ()=>editCard(idx));
    d.appendChild(row);
  });
}
function editCard(i){
  const c = state.detail[i];
  const nextRank = (r)=>{
    const arr = SHOW_ORDER; const j = Math.max(0, arr.indexOf(r)); return arr[(j+1)%arr.length];
  };
  c.rank = nextRank(c.rank||'3');
  c.orientation = c.orientation==='vertical' ? 'horizontal' : 'vertical';
  applyDetailToTallies(); updateDetail(); recalc();
}
function applyDetailToTallies(){
  Object.keys(state.laid).forEach(k=>state.laid[k]=0); Object.keys(state.pay).forEach(k=>state.pay[k]=0);
  state.detail.forEach(c=>{
    if(!c.rank) return;
    if(c.orientation==='vertical') state.laid[c.rank]++;
    else state.pay[c.rank]++;
  });
}

/* OpenCV helpers */
const cvReady = ()=>new Promise(async resolve=>{ while(typeof cv==='undefined' || !cv.Mat){ await sleep(50); } resolve(); });

function toGray(mat){
  const g = new cv.Mat();
  if(mat.type()===cv.CV_8UC1) { mat.copyTo(g); }
  else { cv.cvtColor(mat,g,cv.COLOR_RGBA2GRAY); }
  return g;
}
function thresholdBest(gray){
  const th = new cv.Mat(); cv.threshold(gray, th, 0,255, cv.THRESH_BINARY+cv.THRESH_OTSU); return th;
}
function resizeTo(mat, w,h){
  const out = new cv.Mat(); cv.resize(mat,out,new cv.Size(w,h),0,0,cv.INTER_AREA); return out;
}
function unsharp(gray){
  const blur = new cv.Mat(); cv.GaussianBlur(gray, blur, new cv.Size(3,3), 0);
  const sharp = new cv.Mat(); cv.addWeighted(gray, 1.6, blur, -0.6, 0, sharp); blur.delete(); return sharp;
}

/* Build synthetic templates (letters/numbers) */
const TEMPLATE_W = 60, TEMPLATE_H = 80;
let templates = null; // {label: cv.Mat gray binary}
function buildTemplates(){
  if(templates) return templates;
  templates = {};
  const labels = ["A","K","Q","J","10","9","8","7","6","5","4","3","2","JOLLY"];
  labels.forEach(lbl=>{
    const off = document.createElement('canvas'); off.width=TEMPLATE_W; off.height=TEMPLATE_H;
    const ictx = off.getContext('2d');
    ictx.fillStyle='#fff'; ictx.fillRect(0,0,off.width,off.height);
    ictx.fillStyle='#000';
    const fontMain = (lbl.length>2 ? 28 : (lbl==='10'? 36 : 40));
    ictx.font = `bold ${fontMain}px system-ui, Arial, Helvetica, sans-serif`;
    ictx.textAlign='left'; ictx.textBaseline='top';
    ictx.fillText(lbl, 6, 4);
    const imgData = ictx.getImageData(0,0,off.width,off.height);
    let mat = cv.matFromImageData(imgData);
    let g = toGray(mat); mat.delete();
    let b = thresholdBest(g); g.delete();
    templates[lbl] = b;
  });
  return templates;
}

/* Find cards: detect rectangles */
function findCardContours(edges){
  const contours = new cv.MatVector(); const hierarchy = new cv.Mat();
  cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
  const items = [];
  for(let i=0;i<contours.size();i++){
    const cnt = contours.get(i);
    const peri = cv.arcLength(cnt,true);
    const approx = new cv.Mat(); cv.approxPolyDP(cnt, approx, 0.02*peri, true);
    if(approx.rows===4){
      const rect = cv.minAreaRect(cnt);
      const w = rect.size.width, h = rect.size.height;
      const area = w*h;
      const minArea = state.precise? 2500 : 4000;
      if(area < minArea) { approx.delete(); cnt.delete(); continue; }
      const ratio = Math.min(w,h)/Math.max(w,h);
      if(ratio < 0.55 || ratio > 0.80){ approx.delete(); cnt.delete(); continue; }
      const pts = [];
      for(let j=0;j<4;j++){ pts.push({x: approx.data32S[j*2], y: approx.data32S[j*2+1]}); }
      pts.sort((a,b)=> a.y===b.y ? a.x-b.x : a.y-b.y);
      const top = pts.slice(0,2).sort((a,b)=>a.x-b.x);
      const bot = pts.slice(2).sort((a,b)=>a.x-b.x);
      const quad = [top[0], top[1], bot[1], bot[0]];
      items.push({rect, quad});
    }
    approx.delete(); cnt.delete();
  }
  hierarchy.delete(); contours.delete();
  return items;
}

/* Warp card to upright and extract two corners */
function warpCard(src, quad){
  const dstW=300, dstH=420;
  const dsize = new cv.Size(dstW, dstH);
  const srcTri = cv.matFromArray(4,1,cv.CV_32FC2,new Float32Array([quad[0].x,quad[0].y, quad[1].x,quad[1].y, quad[2].x,quad[2].y, quad[3].x,quad[3].y]));
  const dstTri = cv.matFromArray(4,1,cv.CV_32FC2,new Float32Array([0,0, dstW,0, dstW,dstH, 0,dstH]));
  const M = cv.getPerspectiveTransform(srcTri, dstTri);
  const dst = new cv.Mat();
  cv.warpPerspective(src, dst, M, dsize, cv.INTER_LINEAR, cv.BORDER_REPLICATE);
  srcTri.delete(); dstTri.delete(); M.delete();
  const tl = dst.roi(new cv.Rect(0,0, Math.floor(dstW*0.32), Math.floor(dstH*0.30)));
  const br = dst.roi(new cv.Rect(Math.floor(dstW*0.68), Math.floor(dstH*0.70), Math.floor(dstW*0.32), Math.floor(dstH*0.30)));
  return {card: dst, tl, br};
}

/* Template match best label */
function matchRank(corner){
  let gray = toGray(corner);
  let sharp = unsharp(gray); gray.delete();
  let bin = thresholdBest(sharp);
  let roi = resizeTo(bin, TEMPLATE_W, TEMPLATE_H);
  bin.delete(); sharp.delete();

  const tpls = buildTemplates();
  let best = {label:null, score:-1};
  for(const [label, tpl] of Object.entries(tpls)){
    const result = new cv.Mat();
    cv.matchTemplate(roi, tpl, result, cv.TM_CCOEFF_NORMED);
    const minMax = cv.minMaxLoc(result);
    if(minMax.maxVal > best.score){ best = {label, score: minMax.maxVal}; }
    result.delete();
  }
  roi.delete();
  if(best.score >= (state.precise? 0.55 : 0.62)) return best;
  return {label:null, score:best.score};
}

/* Main analyze */
async function analyze(){
  if(!imgBitmap){ setStatus('Carica una foto prima'); return; }
  setStatus('Caricamento OpenCV…'); setProg(2);
  await cvReady();

  setStatus('Preprocessing…'); setProg(5);
  const src = cv.imread(canvas);
  const gray = toGray(src);
  const blur = new cv.Mat(); cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
  const edges = new cv.Mat(); cv.Canny(blur, edges, state.precise? 30:50, state.precise? 120:150);

  const cards = findCardContours(edges);
  setStatus(`Carte candidate trovate: ${cards.length}`); setProg(25);

  const results = [];
  for(let i=0;i<cards.length;i++){
    const {rect, quad} = cards[i];
    const {card, tl, br} = warpCard(src, quad);
    const m1 = matchRank(tl);
    const m2 = matchRank(br);
    const best = (m1.score >= m2.score) ? m1 : m2;
    const orientation = (rect.size.height>=rect.size.width)? 'vertical' : 'horizontal';

    const xs = quad.map(p=>p.x), ys = quad.map(p=>p.y);
    const x = Math.min(...xs), y=Math.min(...ys);
    const w = Math.max(...xs)-x, h = Math.max(...ys)-y;

    results.push({ x,y,w,h, rank: best.label, score: best.score, orientation });

    tl.delete(); br.delete(); card.delete();
    setStatus(`Analisi carte… ${i+1}/${cards.length}`); setProg(25 + Math.round((i+1)/cards.length*70));
  }

  Object.keys(state.laid).forEach(k=>state.laid[k]=0);
  Object.keys(state.pay).forEach(k=>state.pay[k]=0);
  state.detail = [];

  for(const r of results){
    if(!r.rank) continue;
    if(r.orientation==='vertical') state.laid[r.rank]++;
    else state.pay[r.rank]++;
    state.detail.push({rank:r.rank, orientation:r.orientation, score:r.score});
  }

  ctx.drawImage(imgBitmap,0,0,canvas.width,canvas.height);
  ctx.lineWidth = 2; ctx.font = '12px system-ui';
  for(const b of results){
    ctx.strokeStyle = b.orientation==='vertical'? '#34d399' : '#fbbf24';
    ctx.strokeRect(b.x, b.y, b.w, b.h);
    const label = `${b.rank||'?'} ${b.orientation==='vertical'?'V':'H'} (${b.score?b.score.toFixed(2):'-'})`;
    const tw = ctx.measureText(label).width;
    ctx.fillStyle = '#000c'; ctx.fillRect(b.x, b.y-16, tw+8, 16);
    ctx.fillStyle = '#fff'; ctx.fillText(label, b.x+4, b.y-4);
  }

  updateDetail();
  recalc();
  setStatus('Completato'); setProg(100);

  src.delete(); gray.delete(); blur.delete(); edges.delete();
}

document.getElementById('analyzeBtn').addEventListener('click', ()=>{
  analyze().catch(err=>{ console.error(err); setStatus('Errore: '+err.message); setProg(0); });
});

/* Init */
recalc();
setStatus('Pronto');
</script>
</body>
</html>
