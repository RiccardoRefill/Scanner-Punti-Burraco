<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Riconoscimento Carta – Demo Semplice</title>
<!-- Solo OpenCV.js, niente OCR esterno -->
<script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
<style>
  :root{ --bg:#0b1a13; --line:#183528; --muted:#97b3a5; --accent:#2dd4bf }
  html,body{margin:0;height:100%}
  body{font-family:system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#05210f,#0b1a13);color:#e7f4ee}
  .wrap{max-width:900px;margin:0 auto;padding:16px 16px 80px}
  h1{font-size:20px;margin:0 0 10px;font-weight:800}
  .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  .btn{border:1px solid var(--line);background:#0f3023;color:#eafff7;border-radius:12px;padding:10px 14px;cursor:pointer;font-weight:700}
  .card{display:grid;grid-template-columns:1fr 280px;gap:12px;border:1px solid var(--line);border-radius:14px;overflow:hidden;background:#0e2119}
  canvas{width:100%;height:auto;background:#0d2018}
  .panel{padding:12px}
  .stat{border:1px dashed var(--line);border-radius:12px;padding:10px 12px;background:#0c2218;margin-bottom:8px}
  .muted{color:var(--muted);font-size:12px}
  .big{font-size:26px;font-weight:900}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  @media (max-width:840px){.card{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="wrap">
  <h1>Riconoscimento di <span class="mono">una</span> carta da gioco</h1>
  <div class="row">
    <label class="btn" for="file">Scatta/Carica foto</label>
    <input id="file" type="file" accept="image/*" capture="environment" hidden>
    <button id="go" class="btn">Riconosci carta</button>
    <button id="reset" class="btn" style="background:#10261d">Pulisci</button>
  </div>

  <div class="card" style="margin-top:12px">
    <div class="panel">
      <div class="muted" style="margin-bottom:6px">Suggerimento: inquadra <b>una sola carta</b>, dall'alto, con luce uniforme.</div>
      <canvas id="canvas"></canvas>
    </div>
    <div class="panel" style="border-left:1px solid var(--line)">
      <div class="stat">
        <div class="muted">Stato</div>
        <div id="status">Pronto</div>
      </div>
      <div class="stat">
        <div class="muted">Risultato</div>
        <div class="big"><span id="rank">—</span> <span id="suit"></span></div>
      </div>
      <div class="muted">Se il riconoscimento è impreciso, avvicina la carta e riprova.</div>
    </div>
  </div>
</div>

<script>
const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
const setStatus = (t)=>document.getElementById('status').textContent=t;
const setRank  = (t)=>document.getElementById('rank').textContent=t;
const setSuit  = (t)=>document.getElementById('suit').textContent=t;

// UI refs
const file = document.getElementById('file');
const go   = document.getElementById('go');
const reset= document.getElementById('reset');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d',{willReadFrequently:true});
let imgBitmap = null;

file.addEventListener('change', async ()=>{
  const f = file.files && file.files[0]; if(!f) return;
  const bitmap = await createImageBitmap(f, { imageOrientation: 'from-image' });
  const maxW = 1200, s = Math.min(1, maxW/bitmap.width);
  canvas.width = Math.round(bitmap.width*s); canvas.height = Math.round(bitmap.height*s);
  ctx.drawImage(bitmap,0,0,canvas.width,canvas.height);
  imgBitmap = bitmap; setStatus('Immagine caricata.'); setRank('—'); setSuit('');
});

reset.addEventListener('click',()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); imgBitmap=null; setStatus('Pronto'); setRank('—'); setSuit(''); });

// ====== OpenCV helpers ======
const cvReady = ()=>new Promise(async resolve=>{ while(typeof cv==='undefined' || !cv.Mat){ await sleep(50); } if(!cv.getBuildInformation){ await sleep(200); } resolve(); });
function toGray(mat){ const g=new cv.Mat(); if(mat.type()===cv.CV_8UC1){ mat.copyTo(g); } else { cv.cvtColor(mat,g,cv.COLOR_RGBA2GRAY); } return g; }
function thresholdOtsu(gray){ const th=new cv.Mat(); cv.threshold(gray,th,0,255,cv.THRESH_BINARY+cv.THRESH_OTSU); return th; }
function morphClose(src,k=3,it=1){ const kernel=cv.Mat.ones(k,k,cv.CV_8U); const dst=new cv.Mat(); cv.morphologyEx(src,dst,cv.MORPH_CLOSE,kernel,new cv.Point(-1,-1),it); kernel.delete(); return dst; }
function rectToQuad(rect){ const cx=rect.center.x, cy=rect.center.y, w=rect.size.width, h=rect.size.height, ang=rect.angle*Math.PI/180; const b=Math.cos(ang), a=Math.sin(ang); const dx=[-w/2,w/2,w/2,-w/2]; const dy=[-h/2,-h/2,h/2,h/2]; const q=[]; for(let i=0;i<4;i++){ q.push({x:cx+dx[i]*b - dy[i]*a, y:cy+dx[i]*a + dy[i]*b}); } return q; }
function warp(src, quad, W=300, H=420){ const s=cv.matFromArray(4,1,cv.CV_32FC2,new Float32Array([quad[0].x,quad[0].y, quad[1].x,quad[1].y, quad[2].x,quad[2].y, quad[3].x,quad[3].y])); const d=cv.matFromArray(4,1,cv.CV_32FC2,new Float32Array([0,0, W,0, W,H, 0,H])); const M=cv.getPerspectiveTransform(s,d); const out=new cv.Mat(); cv.warpPerspective(src,out,M,new cv.Size(W,H),cv.INTER_LINEAR,cv.BORDER_REPLICATE); s.delete(); d.delete(); M.delete(); return out; }

// ====== Synthetic templates (rank + suit) ======
const TW=64, TH=84; let templates=null, suitTpl=null;
function buildTemplates(){ if(templates && suitTpl) return; templates={}; suitTpl={};
  const ranks=["A","K","Q","J","10","9","8","7","6","5","4","3","2"]; const suits=["♠","♥","♦","♣"];
  // rank templates (black)
  ranks.forEach(lbl=>{ const c=document.createElement('canvas'); c.width=TW; c.height=TH; const g=c.getContext('2d'); g.fillStyle='#fff'; g.fillRect(0,0,c.width,c.height); g.fillStyle='#000'; const f= (lbl=="10"? 40 : 48); g.font=`900 ${f}px system-ui,Arial`; g.textAlign='left'; g.textBaseline='top'; g.fillText(lbl,6,4); const img=g.getImageData(0,0,TW,TH); let m=cv.matFromImageData(img); let gray=toGray(m); m.delete(); let b=thresholdOtsu(gray); gray.delete(); templates[lbl]=b; });
  // suit templates using font glyphs (two colors)
  suits.forEach(lbl=>{ const c=document.createElement('canvas'); c.width=TW; c.height=TH; const g=c.getContext('2d'); g.fillStyle='#fff'; g.fillRect(0,0,c.width,c.height); g.fillStyle=(lbl==='♥'||lbl==='♦')?'#f00':'#000'; g.font=`900 52px system-ui,Arial`; g.textAlign='left'; g.textBaseline='top'; g.fillText(lbl,6,8); const img=g.getImageData(0,0,TW,TH); let m=cv.matFromImageData(img); let gray=toGray(m); m.delete(); let b=thresholdOtsu(gray); gray.delete(); suitTpl[lbl]=b; });
}

function matchTemplate(roi, tpls){ // returns {label, score}
  let gray=toGray(roi); let bin=thresholdOtsu(gray); gray.delete(); const scaled=new cv.Mat(); cv.resize(bin, scaled, new cv.Size(TW,TH),0,0,cv.INTER_AREA); bin.delete();
  let best={label:null, score:-1}; for(const [label,t] of Object.entries(tpls)){ const res=new cv.Mat(); cv.matchTemplate(scaled,t,res,cv.TM_CCOEFF_NORMED); const mm=cv.minMaxLoc(res); if(mm.maxVal>best.score) best={label, score:mm.maxVal}; res.delete(); }
  scaled.delete(); return best;
}

async function recognizeOne(){
  if(!imgBitmap){ setStatus('Carica una foto prima'); return; }
  setStatus('Carico OpenCV…'); await cvReady(); buildTemplates();

  setStatus('Preprocessing…');
  const src = cv.imread(canvas);
  // 1) Segmentazione per trovare la carta più grande
  const gray = toGray(src); const th = thresholdOtsu(gray); gray.delete();
  const closed = morphClose(th, 5, 2); th.delete();
  const contours=new cv.MatVector(), hier=new cv.Mat();
  cv.findContours(closed,contours,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE); closed.delete(); hier.delete();
  let bestRect=null, bestArea=0, bestQuad=null;
  for(let i=0;i<contours.size();i++){ const cnt=contours.get(i); const rect=cv.minAreaRect(cnt); const area=rect.size.width*rect.size.height; const ar=Math.min(rect.size.width,rect.size.height)/Math.max(rect.size.width,rect.size.height); if(area>bestArea && area>6000 && ar>0.55 && ar<0.80){ bestArea=area; bestRect=rect; bestQuad=rectToQuad(rect); } cnt.delete(); }
  contours.delete();
  if(!bestQuad){ setStatus('Nessuna carta rilevata. Avvicina la carta e riprova.'); src.delete(); return; }

  // 2) Normalizza la carta
  const W=300,H=420; const warped = warp(src, bestQuad, W, H); src.delete();

  // 3) Ritaglia l'angolo in alto a sinistra
  const corner = warped.roi(new cv.Rect(0,0, Math.floor(W*0.35), Math.floor(H*0.35)));

  // 4) Rank & suit via template matching
  const rank = matchTemplate(corner, templates); // es. {label:"A", score:0.8}
  const suit = matchTemplate(corner, suitTpl);  // es. {label:"♥", score:0.7}

  // 5) Mostra risultato
  const rOK = rank.score >= 0.55; // soglie blande per demo
  const sOK = suit.score >= 0.55;
  setRank(rOK? rank.label : ' ? ');
  setSuit(sOK? suit.label : '');
  setStatus(`OK – conf rank ${rank.score.toFixed(2)} / suit ${suit.score.toFixed(2)}`);

  // 6) Disegna il rettangolo trovato
  const dctx = canvas.getContext('2d');
  dctx.drawImage(imgBitmap,0,0,canvas.width,canvas.height);
  const xs=bestQuad.map(p=>p.x), ys=bestQuad.map(p=>p.y);
  dctx.strokeStyle='#2dd4bf'; dctx.lineWidth=3; dctx.strokeRect(Math.min(...xs),Math.min(...ys), Math.max(...xs)-Math.min(...xs), Math.max(...ys)-Math.min(...ys));

  corner.delete(); warped.delete();
}

go.addEventListener('click', ()=>{
  recognizeOne().catch(e=>{ console.error(e); setStatus('Errore: '+(e?.message||e)); });
});
</script>
</body>
</html>
