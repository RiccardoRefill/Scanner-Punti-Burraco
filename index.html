# Recreate the improved index.html file and save it for download
html = r"""<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Burraco Counter – Auto</title>
<!-- OpenCV.js and Tesseract.js from CDN -->
<script async src="https://docs.opencv.org/4.8.0/opencv.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<style>
  :root{ --bg:#0b1a13; --card:#0f241a; --muted:#97b3a5; --accent:#2dd4bf; --line:#183528; }
  html,body{margin:0;height:100%}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial; background:linear-gradient(180deg,#05210f,#0b1a13); color:#e7f4ee}
  .wrap{max-width:1100px;margin:0 auto;padding:16px 16px 120px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
  h1{font-size:22px;margin:0;font-weight:800;letter-spacing:.2px}
  .btn{border:1px solid var(--line);background:#0f3023;color:#eafff7;border-radius:12px;padding:10px 14px;cursor:pointer;font-weight:600}
  .btn:active{transform:translateY(1px)}
  .btn.secondary{background:#10261d}
  .btn.ghost{background:transparent}
  .pill{border-radius:999px;border:1px solid var(--line);padding:6px 10px;margin-right:6px;background:#0c2018}
  .stat{display:flex;align-items:center;gap:8px;border:1px dashed var(--line);border-radius:12px;padding:10px 12px;background:#0c2218}
  .stat .k{color:var(--muted);font-weight:600}
  .stat .v{font-weight:900;font-size:18px}
  .footer{position:fixed;left:0;right:0;bottom:0;background:rgba(5,18,13,.85);backdrop-filter:saturate(120%) blur(6px);border-top:1px solid var(--line)}
  .footer .inner{max-width:1100px;margin:0 auto;padding:12px 16px}
  .result{display:flex;align-items:center;justify-content:space-between}
  .total{font-size:28px;font-weight:900}
  .imgbox{position:relative;border-radius:16px;overflow:hidden;border:1px solid var(--line);background:#0e2119;display:grid;grid-template-columns:1fr 380px;gap:12px;min-height:220px}
  .panel{padding:12px}
  .hint{color:var(--muted);font-size:12px}
  .overlay{position:absolute;inset:0;pointer-events:none}
  canvas{max-width:100%;height:auto;background:#0d2018}
  .list{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .row{display:flex;justify-content:space-between;align-items:center;border:1px solid var(--line);background:#0e2018;border-radius:10px;padding:6px 10px}
  .ok{color:#a7f3d0}
  .warn{color:#fde68a}
  .err{color:#fecaca}
  .small{font-size:12px;color:var(--muted)}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
  .grid-3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .grid-2{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  .tag{display:inline-block;border:1px solid var(--line);padding:3px 8px;border-radius:999px;background:#0c2018;margin:2px}
  .progress{height:6px;background:#0a1c14;border-radius:6px;overflow:hidden;border:1px solid var(--line)}
  .progress>div{height:100%;background:var(--accent);width:0%}
  @media (max-width:1000px){.imgbox{grid-template-columns:1fr}}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Burraco Counter – Riconoscimento automatico</h1>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <label class="btn" for="pick">Scatta/Carica foto</label>
        <input id="pick" type="file" accept="image/*" capture="environment" hidden>
        <button id="analyzeBtn" class="btn">Riconosci punteggi</button>
        <button id="rulesBtn" class="btn secondary">Regole</button>
        <button id="resetBtn" class="btn ghost">Pulisci</button>
      </div>
    </header>

    <div class="imgbox">
      <div class="panel">
        <div class="hint" style="margin-bottom:8px">Suggerimento: scatta dall’alto, buona luce, carte ben stese. Le carte da pagare orizzontali, le sequenze verticali. Il pozzetto non preso a faccia in giù vicino alle carte da pagare.</div>
        <canvas id="canvas"></canvas>
        <div class="overlay" id="overlay"></div>
      </div>
      <div class="panel" style="border-left:1px solid var(--line)">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px">
          <strong>Stato riconoscimento</strong>
          <div class="progress" style="flex:1"><div id="progress"></div></div>
        </div>
        <div id="status" class="small" style="margin:6px 0 10px">Pronto</div>
        <div class="grid-2" style="margin-bottom:10px">
          <div class="stat"><span class="k">Carte a tavola</span><span class="v" id="stat-pos">0</span></div>
          <div class="stat"><span class="k">Carte da pagare</span><span class="v" id="stat-neg">0</span></div>
        </div>
        <div class="grid-2" style="margin-bottom:10px">
          <div class="stat"><span class="k">Bonus totali</span><span class="v" id="stat-bonus">0</span></div>
          <div class="stat"><span class="k">TOTALE</span><span class="v" id="stat-total">0</span></div>
        </div>
        <div style="margin:8px 0"><strong>Dettaglio riconosciuto</strong></div>
        <div id="detail" class="small" style="max-height:260px;overflow:auto;border:1px solid var(--line);border-radius:10px;padding:6px"></div>
        <div style="margin-top:10px">
          <span class="tag">Burraco Puri: <span id="bp">0</span></span>
          <span class="tag">Semipuri: <span id="bs">0</span></span>
          <span class="tag">Impuri: <span id="bi">0</span></span>
        </div>
        <div style="margin-top:6px">
          <label><input type="checkbox" id="chiusura"> Chiusura effettuata</label>
          <label style="margin-left:10px"><input type="checkbox" id="pozzetto"> Pozzetto NON preso</label>
        </div>
        <div class="small" style="margin-top:6px">Puoi correggere i burraco manualmente. Il resto viene calcolato automaticamente dalle carte riconosciute.</div>
      </div>
    </div>
  </div>

  <div class="footer">
    <div class="inner" style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <div class="stat"><span class="k">Carte a tavola</span> <span class="v" id="f-pos">0</span></div>
        <div class="stat"><span class="k">Carte da pagare</span> <span class="v" id="f-neg">0</span></div>
        <div class="stat"><span class="k">Bonus totali</span> <span class="v" id="f-bonus">0</span></div>
      </div>
      <div class="result"><span class="k" style="margin-right:10px">TOTALE</span> <span class="total" id="f-total">0</span></div>
    </div>
  </div>

  <!-- Dialog Regole -->
  <dialog id="rulesDlg" style="border:none;border-radius:16px;padding:0;max-width:520px;width:92%">
    <form method="dialog" style="background:#0b1a13;color:#e7f4ee;border:1px solid var(--line);border-radius:16px;overflow:hidden">
      <div style="padding:14px 16px;border-bottom:1px solid var(--line);display:flex;justify-content:space-between;align-items:center"><strong>Regole & Bonus</strong><button class="btn secondary" value="close">Chiudi</button></div>
      <div style="padding:14px;display:grid;gap:10px">
        <div class="small">Valori carte (classico ITA): 3–7=5, 8–K=10, A=15, 2=20, Jolly=30.</div>
        <label>Bonus Burraco Puro <input type="number" id="r-puro" /></label>
        <label>Bonus Burraco Semipuro <input type="number" id="r-semi" /></label>
        <label>Bonus Burraco Impuro <input type="number" id="r-imp" /></label>
        <label>Bonus Chiusura <input type="number" id="r-chius" /></label>
        <label>Penalità Pozzetto non preso <input type="number" id="r-pozz" /></label>
      </div>
      <div style="padding:14px;border-top:1px solid var(--line);display:flex;justify-content:flex-end;gap:8px"><button class="btn secondary" value="cancel">Annulla</button><button class="btn" id="saveRules" value="default">Salva</button></div>
    </form>
  </dialog>

<script>
// --- Utils ---
const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
const setText = (id, v)=>{ document.getElementById(id).textContent = String(v); };
const setStatus = (t)=>{ document.getElementById('status').textContent = t; };
const setProg = (p)=>{ document.getElementById('progress').style.width = `${Math.max(0, Math.min(100,p))}%`; };

// --- Domain ---
const RANKS = ["Jolly","2","A","K","Q","J","10","9","8","7","6","5","4","3"]; // UI order
const CARD_VALUES = {"3":5,"4":5,"5":5,"6":5,"7":5,"8":10,"9":10,"10":10,"J":10,"Q":10,"K":10,"A":15,"2":20,"Jolly":30};
const rulesDefaults = { puro:200, semi:150, imp:100, chius:100, pozz:-100 };
let rules = JSON.parse(localStorage.getItem('rules-burraco')||'null') || rulesDefaults;

// State
const state = {
  laid: Object.fromEntries(RANKS.map(r=>[r,0])), // verticali
  pay:  Object.fromEntries(RANKS.map(r=>[r,0])), // orizzontali
  bp:0, bs:0, bi:0,
  chius:false, pozz:false,
  detail: [],
};

// Scoring
function sum(bag){ return Object.entries(bag).reduce((a,[rank,c])=> a + (CARD_VALUES[rank]||0)*c, 0); }
function bonus(){ let b = state.bp*rules.puro + state.bs*rules.semi + state.bi*rules.imp; if(state.chius) b+=rules.chius; if(state.pozz) b+=rules.pozz; return b; }
function recalc(){
  const pos = sum(state.laid); const neg = sum(state.pay); const bon = bonus(); const tot = pos - neg + bon;
  setText('stat-pos', pos); setText('stat-neg', neg); setText('stat-bonus', bon); setText('stat-total', tot);
  setText('f-pos', pos); setText('f-neg', neg); setText('f-bonus', bon); setText('f-total', tot);
}

// UI: rules dialog
const dlg = document.getElementById('rulesDlg');
const btnRules = document.getElementById('rulesBtn');
const inpPuro = document.getElementById('r-puro');
const inpSemi = document.getElementById('r-semi');
const inpImp  = document.getElementById('r-imp');
const inpCh   = document.getElementById('r-chius');
const inpPz   = document.getElementById('r-pozz');
btnRules.addEventListener('click', ()=>{ inpPuro.value=rules.puro; inpSemi.value=rules.semi; inpImp.value=rules.imp; inpCh.value=rules.chius; inpPz.value=rules.pozz; dlg.showModal(); });
const saveRules = document.getElementById('saveRules');
saveRules.addEventListener('click', ()=>{ rules={ puro:+inpPuro.value||0, semi:+inpSemi.value||0, imp:+inpImp.value||0, chius:+inpCh.value||0, pozz:+inpPz.value||0 }; localStorage.setItem('rules-burraco', JSON.stringify(rules)); recalc(); });

document.getElementById('chiusura').addEventListener('change', e=>{ state.chius=e.target.checked; recalc(); });
document.getElementById('pozzetto').addEventListener('change', e=>{ state.pozz=e.target.checked; recalc(); });

// Burraco manual adjust (click to cycle values)
['bp','bs','bi'].forEach(id=>{
  document.getElementById(id).addEventListener('click', ()=>{
    state[id] = (state[id]+1)%10; setText(id, state[id]); recalc();
  });
});

// Canvas / image
const input = document.getElementById('pick');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let imgBitmap = null;

input.addEventListener('change', async ()=>{
  const f = input.files && input.files[0]; if(!f) return;
  const bitmap = await createImageBitmap(f, {imageOrientation:'from-image'});
  const maxW = 1200; const scale = Math.min(1, maxW/bitmap.width);
  canvas.width = Math.round(bitmap.width*scale);
  canvas.height= Math.round(bitmap.height*scale);
  ctx.drawImage(bitmap,0,0,canvas.width,canvas.height);
  imgBitmap = bitmap;
  setStatus('Immagine caricata. Pronto al riconoscimento.'); setProg(0);
});

document.getElementById('resetBtn').addEventListener('click', ()=>{
  ctx.clearRect(0,0,canvas.width,canvas.height);
  state.detail = []; Object.keys(state.laid).forEach(k=>state.laid[k]=0); Object.keys(state.pay).forEach(k=>state.pay[k]=0);
  // non azzeriamo i bonus manuali
  updateDetail(); recalc(); setStatus('Pronto'); setProg(0);
});

function drawBoxes(boxes){
  ctx.drawImage(imgBitmap,0,0,canvas.width,canvas.height);
  ctx.lineWidth = 2; ctx.font = '12px system-ui';
  for(const b of boxes){
    ctx.strokeStyle = b.orientation==='vertical'? '#34d399' : '#fbbf24';
    ctx.strokeRect(b.x, b.y, b.w, b.h);
    const label = `${b.rank||'?'} ${b.orientation==='vertical'?'V':'H'}`;
    const tw = ctx.measureText(label).width;
    ctx.fillStyle = '#000c'; ctx.fillRect(b.x, b.y-16, tw+8,16);
    ctx.fillStyle = '#fff'; ctx.fillText(label, b.x+4, b.y-4);
  }
}

function updateDetail(){
  const d = document.getElementById('detail');
  d.innerHTML = '';
  if(!state.detail.length){ d.innerHTML = '<div class="small">Nessuna carta riconosciuta (ancora)</div>'; return; }
  for(const c of state.detail){
    const row = document.createElement('div'); row.className='row';
    row.innerHTML = `<span>${c.rank||'?'} <span class="small">(${c.orientation==='vertical'?'tavola':'pagare'})</span></span><span>${CARD_VALUES[c.rank]||0} pt</span>`;
    d.appendChild(row);
  }
}

// OCR helper (worker riutilizzabile)
const TESS_CONFIG = { 
  logger: m=>{ if(m.status) setStatus(m.status); if(m.progress) setProg(Math.round((m.progress||0)*100)); },
  langPath: 'https://tessdata.projectnaptha.com/4.0.0_best',
};
const OCR_WHITELIST = 'A K Q J 10 9 8 7 6 5 4 3 2 JOLLY';
let tessWorker = null;
async function getWorker(){
  if(!tessWorker){
    tessWorker = await Tesseract.createWorker('eng', 1, TESS_CONFIG);
    await tessWorker.setParameters({ tessedit_char_whitelist: OCR_WHITELIST });
  }
  return tessWorker;
}

function mapTextToRank(text){
  if(!text) return null;
  const t = text.toUpperCase().replace(/[^A-Z0-9]/g,'');
  if(t.includes('JOLLY')) return 'Jolly';
  if(t==='A') return 'A';
  if(t==='K') return 'K';
  if(t==='Q') return 'Q';
  if(t==='J') return 'J';
  if(t==='10' || t==='T') return '10';
  if(/^[2-9]$/.test(t)) return t;
  return null;
}

function toRGBA(mat){
  // Ensure 4 channels for ImageData
  let rgba = new cv.Mat();
  const type = mat.type();
  if (type === cv.CV_8UC4) {
    rgba = mat.clone();
  } else if (type === cv.CV_8UC3) {
    cv.cvtColor(mat, rgba, cv.COLOR_RGB2RGBA);
  } else if (type === cv.CV_8UC1) {
    cv.cvtColor(mat, rgba, cv.COLOR_GRAY2RGBA);
  } else {
    cv.cvtColor(mat, rgba, cv.COLOR_RGBA2RGBA);
  }
  return rgba;
}

function matToImageData(mat){
  const rgba = toRGBA(mat);
  const imgData = new ImageData(new Uint8ClampedArray(rgba.data), rgba.cols, rgba.rows);
  rgba.delete();
  return imgData;
}

// piccoli miglioramenti OCR: resize x2, unsharp, binarizzazione doppia
function enhanceForOCR(gray){
  const big = new cv.Mat();
  cv.resize(gray, big, new cv.Size(0,0), 2.0, 2.0, cv.INTER_CUBIC);
  const blur = new cv.Mat();
  cv.GaussianBlur(big, blur, new cv.Size(3,3), 0);
  const sharp = new cv.Mat();
  // unsharp mask: sharp = 1.5*big - 0.5*blur
  cv.addWeighted(big, 1.5, blur, -0.5, 0, sharp);
  big.delete(); blur.delete();
  return sharp;
}

async function ocrRankFromMat(mat){
  // mat is expected grayscale or RGBA of the small corner; we'll binarize
  const gray = new cv.Mat();
  if(mat.type() === cv.CV_8UC1){ gray.create(mat.rows, mat.cols, cv.CV_8UC1); mat.copyTo(gray); }
  else { cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY); }
  const sharp = enhanceForOCR(gray);
  const th = new cv.Mat();
  cv.threshold(sharp, th, 0, 255, cv.THRESH_BINARY+cv.THRESH_OTSU);
  let rank = await (await getWorker()).recognize(matToImageData(th)).then(r => mapTextToRank(r.data.text.trim()));
  if(!rank){
    // fallback: adaptive threshold
    const th2 = new cv.Mat();
    cv.adaptiveThreshold(sharp, th2, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
    rank = await (await getWorker()).recognize(matToImageData(th2)).then(r => mapTextToRank(r.data.text.trim()));
    th2.delete();
  }
  gray.delete(); sharp.delete(); th.delete();
  return rank;
}

function warpQuadToRect(src, quad){
  const dstW=300, dstH=420;
  const dsize = new cv.Size(dstW, dstH);
  const srcTri = cv.matFromArray(4,1,cv.CV_32FC2, new Float32Array([quad[0].x,quad[0].y, quad[1].x,quad[1].y, quad[2].x,quad[2].y, quad[3].x,quad[3].y]));
  const dstTri = cv.matFromArray(4,1,cv.CV_32FC2, new Float32Array([0,0, dstW,0, dstW,dstH, 0,dstH]));
  const M = cv.getPerspectiveTransform(srcTri, dstTri);
  const dst = new cv.Mat();
  cv.warpPerspective(src, dst, M, dsize, cv.INTER_LINEAR, cv.BORDER_REPLICATE);
  srcTri.delete(); dstTri.delete(); M.delete();
  return dst;
}

function estimateOrientation(rect){
  const { size:{ width:w, height:h } } = rect;
  return (h>=w) ? 'vertical' : 'horizontal';
}

function approxPolyFromContour(cnt){
  const peri = cv.arcLength(cnt, true);
  const approx = new cv.Mat();
  cv.approxPolyDP(cnt, approx, 0.02*peri, true);
  return approx;
}

async function analyze(){
  if(!imgBitmap){ setStatus('Carica una foto prima'); return; }
  setStatus('Caricamento librerie…'); setProg(2);
  while(typeof cv==='undefined' || !cv.Mat){ await sleep(50); }

  setStatus('Preprocessing…'); setProg(5);
  const src = cv.imread(canvas);
  const gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  const blur = new cv.Mat(); cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
  const edges = new cv.Mat(); cv.Canny(blur, edges, 50, 150);

  const contours = new cv.MatVector(); const hierarchy = new cv.Mat();
  cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  const boxes = [];
  for(let i=0; i<contours.size(); i++){
    const cnt = contours.get(i);
    const approx = approxPolyFromContour(cnt);
    if(approx.rows === 4){
      const rect = cv.minAreaRect(cnt);
      const w = rect.size.width, h = rect.size.height;
      const area = w*h; if(area < 4000) { approx.delete(); cnt.delete(); continue; }
      const ratio = Math.min(w,h)/Math.max(w,h);
      if(ratio < 0.60 || ratio > 0.78){ approx.delete(); cnt.delete(); continue; }

      const pts = [];
      for(let j=0;j<4;j++){ pts.push({x: approx.data32S[j*2], y: approx.data32S[j*2+1]}); }
      pts.sort((a,b)=> a.y===b.y ? a.x-b.x : a.y-b.y);
      const top = pts.slice(0,2).sort((a,b)=>a.x-b.x);
      const bot = pts.slice(2).sort((a,b)=>a.x-b.x);
      const quad = [top[0], top[1], bot[1], bot[0]];

      boxes.push({ rect, quad });
    }
    approx.delete(); cnt.delete();
  }

  setStatus(`Trovati ${boxes.length} rettangoli candidati`); setProg(25);
  const results = [];

  for(let idx=0; idx<boxes.length; idx++){
    const { rect, quad } = boxes[idx];
    const upright = warpQuadToRect(src, quad);
    const cx = 0, cy = 0, cw = Math.floor(upright.cols*0.30), ch = Math.floor(upright.rows*0.28);
    const roi = upright.roi(new cv.Rect(cx, cy, cw, ch));
    const rank = await ocrRankFromMat(roi);
    const orientation = estimateOrientation(rect);
    results.push({
      x: Math.min(quad[0].x, quad[1].x, quad[2].x, quad[3].x),
      y: Math.min(quad[0].y, quad[1].y, quad[2].y, quad[3].y),
      w: Math.max(quad[0].x, quad[1].x, quad[2].x, quad[3].x) - Math.min(quad[0].x, quad[1].x, quad[2].x, quad[3].x),
      h: Math.max(quad[0].y, quad[1].y, quad[2].y, quad[3].y) - Math.min(quad[0].y, quad[1].y, quad[2].y, quad[3].y),
      rank: rank || null,
      orientation,
    });

    roi.delete(); upright.delete();
    setStatus(`Analisi carte… ${idx+1}/${boxes.length}`); setProg(25 + Math.round((idx+1)/boxes.length*70));
  }

  Object.keys(state.laid).forEach(k=>state.laid[k]=0); Object.keys(state.pay).forEach(k=>state.pay[k]=0);
  state.detail = [];

  for(const r of results){
    if(!r.rank){ continue; }
    if(r.orientation==='vertical'){ state.laid[r.rank]++; }
    else { state.pay[r.rank]++; }
    state.detail.push({ rank:r.rank, orientation:r.orientation });
  }

  drawBoxes(results);
  updateDetail();
  recalc();
  setStatus('Completato'); setProg(100);

  src.delete(); gray.delete(); blur.delete(); edges.delete(); contours.delete(); hierarchy.delete();

  if(tessWorker){ try { await tessWorker.terminate(); } catch(e){} tessWorker = null; }
}

document.getElementById('analyzeBtn').addEventListener('click', ()=>{
  analyze().catch(err=>{ console.error(err); setStatus('Errore: '+err.message); setProg(0); });
});

// Init
recalc();
setStatus('Pronto');
</script>
</body>
</html>"""
with open("/mnt/data/index.html", "w", encoding="utf-8") as f:
    f.write(html)
print("Creato:", "/mnt/data/index.html")
